#' Create a dataframe for a reaction, containing only basic information
#' @description This function create a dataframe given a reaction id from the rbiopax object
#' @param rbpo A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @param id_single A character string, which is a single reaction id in the specific format defined by the owl file.
#' @param bpclass A character string, which is an annotation of the type of the reaction
#' @details The rbpo$dt is fundamentally a dataframe. The information of a reaction is retrieved by subsetting the dataframe restricting the "id" slot to be "id_single".
#' @details The reaction will have "left" and "right" as the substrates and products; "direction"; "name" as the displayName
#' @details Other slots: "enzyme", "controlType","modulator",and "modulatorType" are only initialized with default value.
#' @return A small dataframe containing the information of a single reaction. The information includes "left", "right", "direction", "name", "enzyme", "controlType", "modulator", "modulatorType".
#' @export
create_singleReactionBackbone<-function(rbpo,id_single,bpclass){
  (df<-data.frame(class = bpclass)) #initialize the dataframe
  (df$id<-id_single)
  (subdf<-rbpo$dt[rbpo$dt$id == id_single,]) #get a subset of the total df
  if(length(subdf$property[subdf$property == "left"]) > 0){
    (myleft<-paste0(sort(subdf$property_attr_value[subdf$property == "left"],decreasing = F),collapse = ";")) #sort the ids to ensure unique id for each reaction
  }else{
    myleft<-"NoLeftMembers"
  }
  if(length(subdf$property[subdf$property == "right"]) > 0){
    (myright<-paste0(sort(subdf$property_attr_value[subdf$property == "right"],decreasing = F),collapse = ";")) #sort the ids to ensure unique id for each reaction
  }else if(length(subdf$property[subdf$property == "product"]) > 0){ #for class::TemplateReactions only
    (myright<-paste0(sort(subdf$property_attr_value[subdf$property == "product"],decreasing = F),collapse = ";")) 
  }else{
    myright<-"NoRightMembers"
  }
  df$left<-myleft
  df$right<-myright
  if(length(subdf$property_value[subdf$property == "conversionDirection"]) > 0){
    (df$direction<-subdf$property_value[subdf$property == "conversionDirection"])
  }else{
    df$direction<-"NA"
  }
  
  if(length(subdf$property[subdf$property == "displayName"]) > 0){
    (thisname<-paste0(sort(subdf$property_value[subdf$property == "displayName"],decreasing = F),collapse = ";"))
  }else{
    thisname<-"NoNameAvailable"
  }
  df$name<-thisname
  df$enzyme<-"NoEnzyme"
  df$controlType<-"NA"
  df$modulator<-"NoModulator"
  df$modulateType<-"NA"
  return(df)
}

#' Retrieve all the intended class of reactions from a rBioPax object
#' @description This function takes a rBioPax object and the type of desired class, then build a backbone of dataframe containing all the reactions without enzyme information.
#' @param rbpo A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @param bpclass A character string, describing the type of desired class. Available classes can be searched in rbpo$dt
#' @details This is a wrapper to loop for all the reaction ids, creating a dataframe of basic information of reactions
#' @return This function returns a dataframe, containing the substrate and products of each reactions.
#' @export
extract_reactionInfo<-function(rbpo,bpclass){
  id_br<-unique(rbpo$dt$id[rbpo$dt$class == bpclass]) #get the ids of the intended class
  (df<-create_singleReactionBackbone(rbpo,id_br[1],bpclass))
  if(length(id_br) >=2){
    for(i in 2:length(id_br)){
      (df<-rbind(df,create_singleReactionBackbone(rbpo,id_br[i],bpclass)))
      totaln=length(id_br)
      if(i %% 1000 ==0){
        print(paste0("Finished ",i," reactions, total ",totaln))
      }
    }
  }
  return(df)
}

#' Add the information of enzymes to the dataframe of reactions
#' @description This function extracts the desired type of enzyme ids from the rBioPax object, and add them to the reactions
#' @param tmpr A dataframe created by function "extract_reactionInfo", containing the backbone of reactions
#' @param rbpo A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @param enzymeClass A character string, describing the type of desired class. Available classes can be searched in rbpo$dt
#' @param verbose Logical, TRUE or FALSE. Whether to print  messages.
#' @details This function searches for the ids of a given enzyme type, then track down the reaction id catalyzed by the enzyme, then add the info of the enzyme to the reaction. The enzyme types are one of "Catalysis" or "Control". 
#' @return A dataframe with enzyme info of desired type of enzymes.
#' @export
add_enzymeInfo<-function(tmpr,rbpo,enzymeClass,verbose=TRUE){
  id_all<-unique(rbpo$dt$id[rbpo$dt$class == enzymeClass])
  #tmpr$controlType<-"NA"
  for(i in 1:length(id_all)){
    (subdf<-rbpo$dt[rbpo$dt$id == id_all[i],])
    if(length(subdf$property[subdf$property == "controlled"]) > 1){
      if(verbose){
        print("Multiple controlled reactions detected")
      }
      break
    }else if(length(subdf$property[subdf$property == "controlled"]) < 1){
      if(verbose){
        print(paste0("No controlled reactions found, skip ",subdf$id[1]))
      }
      next
    }else{
      (tmprid<-gsub("#","",subdf$property_attr_value[subdf$property == "controlled"]))
    }
    #multiple controllers of a single enzyme catalysis id is considered to work together to conduct the catalysis behavior
    #different enzymes that catalyze the same reaction will have different records when building the reactions.full object
    (allctrl<-paste0(sort(subdf$property_attr_value[subdf$property == "controller"],decreasing = F),collapse = ";")) 
    if(length(which(tmpr$id == tmprid)) == 0){ #tmprid has been restricted to contain only one element
      if(verbose){
        print(paste0("Unexpected failure, class: ",enzymeClass,", id_indx: ",i, ", reaction_id: ",tmprid))
      }
    }else if(length(tmpr$enzyme[tmpr$id == tmprid]) == 1){
      #check whether the reaction has been annotated, if no, then directly change the values, if yes, create a new record of the same reaction id, but with different enzyme
      if(tmpr$enzyme[tmpr$id == tmprid] == "NoEnzyme"){ #not been annotated
        tmpr$enzyme[tmpr$id == tmprid] <- allctrl
        if(length(subdf$property_value[subdf$property == "controlType"]) == 1){
          (tmpr$controlType[tmpr$id == tmprid] <- subdf$property_value[subdf$property == "controlType"])
        }else if(length(subdf$property_value[subdf$property == "controlType"]) > 1){
          print(paste0("Multiple control types detected: ",tmprid,". These types are glued by \';\'."))
          (tmpr$controlType[tmpr$id == tmprid] <- paste0( subdf$property_value[subdf$property == "controlType"], collapse = ";")) #multiple control types are glued by ";"
        }
      }else{ #been annotated, so this is a second enzyme that control the same reaction, create a new record
        tmpdf<-tmpr[tmpr$id == tmprid,]
        tmpdf$enzyme[1] <- allctrl
        if(length(subdf$property_value[subdf$property == "controlType"]) == 1){
          (tmpr$controlType[tmpr$id == tmprid] <- subdf$property_value[subdf$property == "controlType"])
        }else if(length(subdf$property_value[subdf$property == "controlType"]) > 1){
          print(paste0("Multiple control types detected: ",tmprid,". These types are glued by \';\'."))
          (tmpr$controlType[tmpr$id == tmprid] <- paste0( subdf$property_value[subdf$property == "controlType"], collapse = ";")) #multiple control types are glued by ";"
        }
        tmpr<-rbind(tmpr,tmpdf)
      }
    }#else{ #more than two enzymes to either activate or inhibit the reaction
    #print(paste0("More than one enzyme to activate/inhibit the reaction ",tmprid))
    #tmpdf<-tmpr[tmpr$id == tmprid,] #tmpdf now has multiple rows
    #tmpdf<-tmpdf[1,] #take the first row
    #tmpdf$enzyme[1] <- allctrl
    #(tmpdf$controlType[tmpdf$id == tmprid] <- subdf$property_value[subdf$property == "controlType"])
    #tmpr<-rbind(tmpr,tmpdf)
    #}
    totaln=length(id_all)
    if(i %% 1000 ==0){
      print(paste0("Finished ",i," enzymes, total ",totaln))
    }
  }
  return(tmpr)
}

#' Add the information of modulator to the dataframe of reactions
#' @description This function extracts the modulators from the rBioPax object if exist, and add them to the reactions
#' @param tmpr A dataframe created by function "extract_reactionInfo", containing the information of reactions
#' @param rbpo A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @param enzymeClass A character string, describing the type of desired class. Default is "Modulation". Will expand additional functions in future.
#' @param verbose Logical, TRUE or FALSE. Whether to print  messages.
#' @details This function searches for the ids of modulator, then track down the reaction id catalyzed by the enzyme, and add the info of the enzyme to the reaction. 
#' @details Modulation is a distinct class compared to "Catalysis" and "Control", since it is defined to record enzymes that change the state of another enzyme which catalyze a reaction. 
#' @details Some databases use "Modulation", while some use "Control" to store the same reactions.
#' @return A dataframe with modulation's info for reactions.
#' @export
add_modulationInfo<-function(tmpr,rbpo,enzymeClass="Modulation",verbose=TRUE){
  id_all<-unique(rbpo$dt$id[rbpo$dt$class == enzymeClass])
  #tmpr$controlType<-"NA"
  for(i in 1:length(id_all)){
    (subdf<-rbpo$dt[rbpo$dt$id == id_all[i],])
    if(length(subdf$property[subdf$property == "controlled"]) > 1){
      if(verbose){
        print(paste0("Multiple controlled Catalysis detected, Modulation id: ", id_all[i]))
      }
      break
    }else{
      (tmpcid<-gsub("#","",subdf$property_attr_value[subdf$property == "controlled"]))# tmp_catalysis_id
    }
    (allctrl<-paste0(sort(subdf$property_attr_value[subdf$property == "controller"],decreasing = F),collapse = ";")) #all controller
    #track down the catalysis id's info
    (subdf.c<-rbpo$dt[rbpo$dt$id == tmpcid,])
    if(length(subdf.c$property[subdf.c$property == "controlled"]) > 1){
      if(verbose){
        print(paste0("Multiple controlled reactions detected, Catalysis id: ",tmpcid))
      }
      break
    }else{
      (tmprid<-gsub("#","",subdf.c$property_attr_value[subdf.c$property == "controlled"]))# tmp_reation_id
    }
    if(length(which(tmpr$id == tmprid)) == 0){
      if(verbose){
        print(paste0("Unexpected failure, class: ",enzymeClass,", id_indx: ",i, ", reaction_id: ",tmprid))
      }
    }
    if(length(tmpr$enzyme[tmpr$id == tmprid]) == 1){
      #$modulator<-"NoModulator"
      #check whether the reaction has been annotated, if no, then directly change the values, if yes, create a new record of the same reaction id, but with different enzyme
      if(tmpr$modulator[tmpr$id == tmprid] == "NoModulator"){ #not been annotated
        tmpr$modulator[tmpr$id == tmprid] <- allctrl
        (tmpr$modulateType[tmpr$id == tmprid] <- subdf$property_value[subdf$property == "controlType"])
      }else{ #been annotated, create a new record
        tmpdf<-tmpr[tmpr$id == tmprid,]
        tmpdf$modulator[1] <- allctrl
        (tmpdf$modulateType[1] <- subdf$property_value[subdf$property == "controlType"])
        tmpr<-rbind(tmpr,tmpdf)
      }
    }else{ #more than two enzymes to either activate or inhibit the reaction
      #print(paste0("More than one enzyme to activate/inhibit the reaction ",tmprid))
      tmpdf<-tmpr[tmpr$id == tmprid,] #tmpdf now has multiple rows
      tmpdf<-tmpdf[1,] #take the first row
      tmpdf$modulator[1] <- allctrl
      (tmpdf$modulateType[tmpdf$id == tmprid] <- subdf$property_value[subdf$property == "controlType"])
      tmpr<-rbind(tmpr,tmpdf)
    }
    totaln=length(id_all)
    if(i %% 1000 ==0){
      print(paste0("Finished ",i," enzymes, total ",totaln))
    }
  }
  return(tmpr)
}

#' Build a vector containing the components of ids.
#' @description This function break down the ids in a given vector into their components recursively.
#' @param myvec A vector containing the ids which need to be decomposed
#' @param rbpo A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @details This function takes a vector of ids. For each id, this function tries to break it down into its components. Sometimes an id is not a complex, but a "set". A set will also be broken down into its elements.
#' @return A vector containing the decomposed ids or original ids if they are not able to be decomposed.
#' @export
build_component_structure<-function(myvec,rbpo){
  myresult<-c()
  while(length(myvec)>0){
    (idtmp<-myvec[1]) #take the first element
    (idtmp<-unlist(strsplit(idtmp,"#")))
    (idtmp.id<-idtmp[1])
    (idtmp.label<-paste0(idtmp[2:length(idtmp)],collapse = "#"))
    if(length(myvec) > 1){ #the rest of the elements move forward
      (myvec<-myvec[2:length(myvec)])
    }else{ #when there's only one element left, the vector should be empty after taking out the first element
      (myvec<-NULL)
    }
    #(vec.comp<-listComplexComponents(rbpo,idtmp,returnIDonly = TRUE)) #try to get the components of this id
    (vec.comp<-gsub("#","",rbpo$dt$property_attr_value[rbpo$dt$id == idtmp.id & rbpo$dt$property == "component"]))
    if(length(vec.comp) > 0){
      #handle the label!
      (vec.comp<-paste0(vec.comp,"#",idtmp.label,"#c",1:length(vec.comp)))
      (myvec<-c(myvec,vec.comp)) #the decomplexed elements should be put back to the vector
    }else{ #if it's not a complex, check whether it's a Set
      (vec.set<-gsub("#","",rbpo$dt$property_attr_value[rbpo$dt$id == idtmp.id & rbpo$dt$property == "memberPhysicalEntity"]))
      if(length(vec.set) > 0){
        (vec.set<-paste0(vec.set,"#",idtmp.label,"#s",1:length(vec.set)))
        (myvec<-c(myvec,vec.set))
      }else{ #when it does not contain components or members, put it into result
        (myresult<-c(myresult,paste0(idtmp,collapse = "#")))
      }
    }
  }
  return(myresult)
}

#' Decompose a complex id into its components
#' @description This function break down an id, calling the function "build_component_structure"
#' @param cplx An internal id from "rbpo"
#' @param rbpo A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @details This function takes an id, searches for components and set elements, then calling "build_component_structure" to decompose recursively.
#' @return A vector containing the decomposed ids or original ids if they are not able to be decomposed.
#' @export
decomplex<-function(cplx,rbpo){
  (subdf<-rbpo$dt[rbpo$dt$id == cplx,])
  (myvec.c<-gsub("#","",subdf$property_attr_value[subdf$property == "component"])) #for components
  (myvec.s<-gsub("#","",subdf$property_attr_value[subdf$property == "memberPhysicalEntity"])) #for sets
  #(myvec<-listComplexComponents(rbpo,cplx,returnIDonly = TRUE))
  if(length(myvec.c) > 0 & length(myvec.s) > 0){
    print(paste0("Mixed components and sets detected for complex ",cplx))
  }
  myresult<-c()
  if(length(myvec.c) > 0){ #label each element with "#c1, #c2..."
    (myvec.c<-paste0(myvec.c,"#c",1:length(myvec.c)))
  }
  if(length(myvec.s) > 0){
    (myvec.s<-paste0(myvec.s,"#s",1:length(myvec.s)))
  }
  if(length(myvec.c) == 0 & length(myvec.s == 0)){
    
  }else{
    myresult<-c(myresult,build_component_structure(myvec.c,rbpo))
    myresult<-c(myresult,build_component_structure(myvec.s,rbpo))
  }
  return(sort(myresult,decreasing = F))
}

#' Build a table containing the matching information of complexes and their components
#' @description This function create a dataframe by decomposing all the ids of "Complex" into components and set elements.
#' @param rbpo A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @param class.this A character string specifying the class of the ids. Default if "Complex".
#' @details This function searches for all of the ids of "Complex", then loop for each id and decompose into components and elements, and collapse the resulting ids by "_", and finally store the matching info in a dataframe.
#' @return A two-column dataframe containing the original ids of "Complex" class and the decomposed ids collapsed by "_".
#' @export
create_complexComponentTable<-function(rbpo,class.this="Complex"){
  (df.result<-data.frame(complex = unique(rbpo$dt$id[rbpo$dt$class == class.this])))
  df.result$components<-"Nothing"
  for(i in 1:dim(df.result)[1]){
    (tmpid<-df.result$complex[i])
    (tmpvec<-decomplex(tmpid,rbpo))
    (df.result$components[i]<-paste0(sort(unique(substr(tmpvec,1,regexpr("#",tmpvec)-1)),decreasing = F),collapse = "_"))
    if(i %% 10 == 0){
      print(paste0("Processed ",i," ids, total ",dim(df.result)[1]))
    }
  }
  (df.result<-df.result[df.result$components != "",])
  return(df.result)
}

#' Replace the ids in a vector with the decomposed id strings
#' @description This function try to search in the complex to component matching table to replace the ids in a given vector.
#' @param vec.in A vector containing molecular ids.
#' @param matchTable A two-column dataframe containing the original complex ids and the decomposed id strings. The table can be created by "create_complexComponentTable".
#' @details This function replaces the ids in the given vector with decomposed id strings, using the match table created by "create_complexComponentTable".
#' @return A vector of ids which are decomposed into components or elements.
#' @export
replace_complexWithComponent<-function(vec.in,matchTable = cplx2cpnt){
  vec.in<-as.character(na.omit(vec.in))
  if(length(vec.in) > 0){
    for(j in 1:length(vec.in)){#replace the complex id with component combination
      tmp.match<-matchTable$components[matchTable$complex == vec.in[j]]
      if(length(tmp.match) == 1){
        vec.in[j]<-tmp.match
      }else if(length(tmp.match) > 1){
        print(paste0("Unexpected situation found: one complex map to multiple component combinations: ",vec.in))
        vec.in[j]<-tmp.match[1]
      }
    }
  }else{
    vec.in<-"NoData"
  }
  return(vec.in)
}

#' Generate intermediate nodes for a reaction.
#' @description This function generates intermediate nodes.
#' @param vec.substrate A vector containing the ids of substrates of a reaction.
#' @param enzyme A character string of the enzyme id of a reaction. If there's no enzyme info for this reaction, then this value will be "NoEnzyem" or "".
#' @param controlType A character string specifying the control type of the enzyme to the reaction. This info can be retrieved by the function "add_enzymeInfo" when building the table of reactions.
#' @param modulator A character string of the modulator id. A modulator changes the state of an enzyme which catalyze a reaction.
#' @param modulateType A character string specifying the control type of the modulator to the enzyme. Generally it's either a positive or a negative relation.
#' @param complexTable A two-column dataframe which provides matching info between complexes and their components or elements.
#' @param reactionID A character string of a reaction id. Should match the other parameters except "complexTable".
#' @details This function aggregates the information of substrates and enzyme of a reaction and forms the name of an intermediate node. If a modulator presents in the reaction, then this function will create additional intermedate nodes for the reactions between enzyme and modulator, and store the edges in the second element of the result list. Note the intermediate node of enzyme;modulator will point to the reaction's intermediate node (substrates;enzyme) to avoid ambiguity.
#' @return A list containing the intermediate node of the reaction. If there is a modulator in the reaction, then the list will have a second element which stores the edges describing the interactions between the modulator, enzyme and the reaction.
#' @export
generate_intermediate <- function(vec.substrate,enzyme,controlType,modulator,modulateType, complexTable,reactionID){
  result.final <- list() #need to pass the sif records of modulators if generated
  if(enzyme == "NoEnzyme" | nchar(enzyme) == 0){ #enzyme can be either "NoEnzyme" or "" 
    (tmp.itmd<-paste0(sort(vec.substrate,decreasing = F),collapse = ";")) #the intermediate node.
    result.final[[1]]<-tmp.itmd
    if(modulator != "NoModulator" & nchar(modulator) != 0){
      print(paste0("Warning: modulator presents in a reaction with no enzyme, reaction id: ",df.reactions$id[i]))
    }
  }else{ #If enzymes present, put the enzymes into the intermediate node too.
    (vec.enzyme<-unlist(strsplit(gsub("#","",enzyme),";"))) 
    (vec.enzyme<-replace_complexWithComponent(vec.enzyme,matchTable = complexTable)) #sometimes the enzyme is a complex
    #Multiple enzymes in one Catalysis id were collapsed using ";". 
    #Currently it does not split different enzymes in one Catalysis id into different reactions
    (tmp.itmd<-paste0(sort(c(vec.substrate,vec.enzyme),decreasing = F),collapse = ";"))
    result.final[[1]]<-tmp.itmd
    if(modulator != "NoModulator" & nchar(modulator) != 0){ #If there's an enzyme controlling this reaction, and a modulator which controls the enzyme
      #Modulators with different modulation ids are stored in separated reaction records
      #Using a vector and strsplit function are only for the possibility of multiple modulators with the same modulation id 
      (vec.modulator<-unlist(strsplit(gsub("#","",modulator),";")))
      (vec.modulator<-replace_complexWithComponent(vec.modulator,matchTable = complexTable))
      (tmp.enmod<-paste0(sort(c(vec.enzyme,vec.modulator),decreasing = F),collapse = ";")) #enzyme-modulator intermediate
      #Here we do not enumerate the enzymes (if there are many of them) one by one, since enzymes with different
      #catalysis ids have been stored in different reaction ids. Here we only create the edges between enzymes and en-mod, and modulators and en-mod
      result.sif<-data.frame(left=paste0(sort(vec.enzyme,decreasing = F),collapse = ";"),
                             right=tmp.enmod,
                             type="Generate",reactionID=reactionID)
      result.sif<-rbind(result.sif,data.frame(left=paste0(sort(vec.modulator,decreasing = F),collapse = ";"),
                                              right=tmp.enmod,
                                              type="Generate",reactionID=reactionID))
      #Now we create the edges between the en-mod and the intermediate of this reaction.
      #By definition, the modulators interact with the enzymes and affect the enzymes' capability of catalyzing the reactions, i.e.
      #the capability of generating the intermediate of the reactions
      result.sif<-rbind(result.sif,data.frame(left=tmp.enmod,
                                              right=tmp.itmd,
                                              type=modulateType,reactionID=reactionID))
      result.final[[2]]<-result.sif #only when modulators present in the record will there be a second element in the list
    }
  }
  return(result.final)
}

#' Generate edges based on the information of a reaction
#' @description This function generates edges based on the substrates, products, enzymes and intermediate nodes of a reaction.
#' @param vec.substrate A vector containing the ids of substrates of a reaction.
#' @param vec.product A vector containing the ids of products of a reaction.
#' @param enzyme A character string of the enzyme id of a reaction. If there's no enzyme info for this reaction, then this value will be "NoEnzyem" or "".
#' @param controlType A character string specifying the control type of the enzyme to the reaction. This info can be retrieved by the function "add_enzymeInfo" when building the table of reactions.
#' @param tmp.itmd A character string specifying the name of the intermediate node for this reaction. Generated by function "generate_intermediate".
#' @param reactionID A character string of a reaction id. Should match the other parameters.
#' @details This function generates edges from substrates and enzymes to intermediate, and from intermediate to products.
#' @return A three-column dataframe containing the edges from substrates and enzymes to intermediate, and from intermediate to products.
#' @export
create_edgesFromReaction<-function(vec.substrate,vec.product,enzyme,controlType,tmp.itmd,reactionID){
  result.sif<-data.frame(left="",right="",type="",reactionID="")
  if(length(vec.substrate) == 1 & (enzyme == "NoEnzyme" | nchar(enzyme) == 0)){ #A->B+C... avoid creating an edge pointing to the substrate itself
    for(j in 1:length(vec.product)){
      if(controlType == "NA"){
        result.sif<-rbind(result.sif,data.frame(left=vec.substrate,right=vec.product[j],type="Generate",reactionID=reactionID))
      }else{
        result.sif<-rbind(result.sif,data.frame(left=vec.substrate,right=vec.product[j],type=controlType,reactionID=reactionID))
      }
    }
  }else{
    for(j in 1:length(vec.substrate)){
      result.sif<-rbind(result.sif,data.frame(left=vec.substrate[j],right=tmp.itmd,type="Generate",reactionID=reactionID))
    }
    for(j in 1:length(vec.product)){
      if(controlType == "NA"){
        result.sif<-rbind(result.sif,data.frame(left=tmp.itmd,right=vec.product[j],type="Generate",reactionID=reactionID))
      }else{
        result.sif<-rbind(result.sif,data.frame(left=tmp.itmd,right=vec.product[j],type=controlType,reactionID=reactionID))
      }
    }
  }
  result.sif<-result.sif[2:dim(result.sif)[1],]
  return(result.sif)
}

#' Convert the reaction table into SIFI format
#' @description This function takes the dataframe of the reactions and convert the reactions into topological network in simple interactions format with intermediates.
#' @param df.reactions A dataframe containing the information of all of the reactions of a database.
#' @param matchTable A dataframe which stores the matching information between complexes and components/elements
#' @details This function calls several other functions to decompose the complexes, generate intermediates, and create edges in SIFI format. The SIFI format is similar to SIF format, but with additional intermediate nodes.
#' @return A three-column dataframe containing the edges from substrates and enzymes to intermediate, and from intermediate to products.
#' @export
convert_toSif<-function(df.reactions,matchTable = cplx2cpnt){
  result.sif<-data.frame(left="",right="",type="",reactionID="")
  for(i in 1:dim(df.reactions)[1]){
    (vec.left<-unlist(strsplit(gsub("#","",df.reactions[i,3]),";")))
    (vec.right<-unlist(strsplit(gsub("#","",df.reactions[i,4]),";")))
    (vec.left<-replace_complexWithComponent(vec.left,matchTable = matchTable))
    (vec.right<-replace_complexWithComponent(vec.right,matchTable = matchTable))
    if(df.reactions$direction[i] == "NA" | df.reactions$direction[i] == "LEFT-TO-RIGHT"){
      #print(i)
      tmp.result<-generate_intermediate(vec.left,
                                        reactions.full$enzyme[i],reactions.full$controlType[i],
                                        reactions.full$modulator[i],reactions.full$modulateType[i],matchTable,reactions.full$id[i])
      (tmp.itmd<-tmp.result[[1]])
      #now the intermediate node has been created, start creating the relations
      if(length(tmp.result) == 2){ #if there are modulators, tmp.result will have two elements, and the second one contains a dataframe of modulators
        result.sif<-rbind(result.sif,tmp.result[[2]])
      }
      result.sif<-rbind(result.sif,create_edgesFromReaction(vec.left,vec.right,
                                                            reactions.full$enzyme[i],reactions.full$controlType[i],
                                                            tmp.itmd,reactions.full$id[i]))
    }else if(df.reactions$direction[i] == "RIGHT-TO-LEFT"){
      tmp.result<-generate_intermediate(vec.right,
                                        reactions.full$enzyme[i],reactions.full$controlType[i],
                                        reactions.full$modulator[i],reactions.full$modulateType[i],matchTable,reactions.full$id[i])
      tmp.itmd<-tmp.result[[1]]
      #now the intermediate node has been created, start creating the relations
      if(length(tmp.result) == 2){ #if there are modulators, tmp.result will have two elements, and the second one contains a dataframe of modulators
        result.sif<-rbind(result.sif,tmp.result[[2]])
      }
      result.sif<-rbind(result.sif,create_edgesFromReaction(vec.right,vec.left,
                                                            reactions.full$enzyme[i],reactions.full$controlType[i],
                                                            tmp.itmd,reactions.full$id[i]))
    }else if(df.reactions$direction[i] == "REVERSIBLE"){
      #from left to right
      tmp.result<-generate_intermediate(vec.left,
                                        reactions.full$enzyme[i],reactions.full$controlType[i],
                                        reactions.full$modulator[i],reactions.full$modulateType[i],matchTable,reactions.full$id[i])
      (tmp.itmd<-tmp.result[[1]])
      #now the intermediate node has been created, start creating the relations
      if(length(tmp.result) == 2){ #if there are modulators, tmp.result will have two elements, and the second one contains a dataframe of modulators
        result.sif<-rbind(result.sif,tmp.result[[2]])
      }
      result.sif<-rbind(result.sif,create_edgesFromReaction(vec.left,vec.right,
                                                            reactions.full$enzyme[i],reactions.full$controlType[i],
                                                            tmp.itmd,reactions.full$id[i]))
      #from right to left
      tmp.result<-generate_intermediate(vec.right,
                                        reactions.full$enzyme[i],reactions.full$controlType[i],
                                        reactions.full$modulator[i],reactions.full$modulateType[i],matchTable,reactions.full$id[i])
      tmp.itmd<-tmp.result[[1]]
      #now the intermediate node has been created, start creating the relations
      if(length(tmp.result) == 2){ #if there are modulators, tmp.result will have two elements, and the second one contains a dataframe of modulators
        result.sif<-rbind(result.sif,tmp.result[[2]])
      }
      result.sif<-rbind(result.sif,create_edgesFromReaction(vec.right,vec.left,
                                                            reactions.full$enzyme[i],reactions.full$controlType[i],
                                                            tmp.itmd,reactions.full$id[i]))
    }
    #The direction of enzyme to intermediate does not change
    if(df.reactions$enzyme[i] != "NoEnzyme" & nchar(df.reactions$enzyme[i]) != 0){ #Generate the relations between enzymes and intermediates
      (vec.enzyme<-unlist(strsplit(gsub("#","",df.reactions$enzyme[i]),";"))) 
      (vec.enzyme<-replace_complexWithComponent(vec.enzyme,matchTable = matchTable)) #sometimes the enzyme is a complex
      for(j in 1:length(vec.enzyme)){
        result.sif<-rbind(result.sif,data.frame(left=vec.enzyme[j],right=tmp.itmd,type="Generate",reactionID=df.reactions$id[i]))
      }
    }
    if(i %% 100 ==0){
      print(paste0("Processed ",i," reactions, total ",dim(df.reactions)[1]))
    }
  }
  result.sif<-result.sif[2:dim(result.sif)[1],]
  return(result.sif)
}

#' Replace internal ids with external ids
#' @description This function replaces the ids which is only meaningful within the use of a specific database with ids in commonly used formats (for example gene symbol and CHEBI id).
#' @param biopax A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @param sif A dataframe in SIFI format, containing the edges with internal ids.
#' @param start An integar specifying the starting line of the looping. Useful for paralleling the processing of large databases. Should be smaller than end.
#' @param end An integar specifying the ending line of the looping. Useful for paralleling the processing of large databases. Should be bigger than start.
#' @param matchTable A two-column dataframe, with the first column containing the strings that need to be replaced, and the second column containing the strings after replacement. Example: replace "uniprot:" with "UniProt".
#' @param globalReplace.before A vector of two elements, specifying the global treatment of special characters which are not desired. This action will be taken BEFORE the replacement of internal ids with external ids. Default (c("_","-")) is to replace "_" with "-".
#' @param globalReplace.after A vector of two elements, specifying the global treatment of special characters which are not desired. This action will be taken AFTER the replacement of internal ids with external ids. Default (c(" ","-")) is to replace " " with "-".
#' @param nreport An integar specifying the limit number of candidate annotations for reporting. Will be passed to function "get_id_annotation".
#' @param verbose Logical, TRUE or FALSE. Whether to report warnings.
#' @details This function calls several other functions to replace the ids which is only meaningful within the use of a specific database with ids in commonly used formats. 
#' @return A three-column dataframe containing the edges from substrates and enzymes to intermediate, and from intermediate to products, using external ids.
#' @export
replace_id_with_annotation<-function(biopax,sif,start,end,matchTable,
                                     globalReplace.before=c("_","-"),
                                     globalReplace.after=c(" ","-"),
                                     nreport=1,verbose=TRUE){
  for(i in start:end){
    (tmp.left<-unlist(strsplit(sif$left[i],";")))
    (tmp.right<-unlist(strsplit(sif$right[i],";")))
    for(j in 1:length(tmp.left)){
      (tmp.vec<-unlist(strsplit(tmp.left[j],"_")))#the record uses ";" to split the substrates in an intermediate; uses "_" to split different component members in a substrate
      for(k in 1:length(tmp.vec)){
        (tmp.vec[k]<-get_id_annotation(biopax,tmp.vec[k],i,matchTable,globalReplace.before,globalReplace.after,verbose=verbose))
      }
      (tmp.left[j]<-paste0(tmp.vec,collapse = "_")) #update tmp.left[j] with replaced ids
    }
    (sif$left[i]<-paste0(tmp.left,collapse = ";"))
    for(j in 1:length(tmp.right)){
      (tmp.vec<-unlist(strsplit(tmp.right[j],"_")))#the record uses ";" to split the substrates in an intermediate; uses "_" to split different component members in a substrate
      for(k in 1:length(tmp.vec)){
        (tmp.vec[k]<-get_id_annotation(biopax,tmp.vec[k],i,matchTable,globalReplace.before,globalReplace.after,verbose=verbose))
      }
      tmp.right[j]<-paste0(tmp.vec,collapse = "_") #update tmp.left[j] with replaced ids
    }
    (sif$right[i]<-paste0(tmp.right,collapse = ";"))
    if(i %% 100 == 0){
      print(paste0("Finished ",i," lines, total ",dim(sif)[1]))
    }
  }
  return(sif)
}

#' Retrieve the external ids/annotations of a given internal id
#' @description This function search for the external ids or annotations of a given internal id, while removing the special characters.
#' @param biopax A rBioPax object generated by reading an owl file using package "rBiopaxParser".
#' @param id A character string of an internal id. It must be an id of a gene/protein or metabolite.
#' @param i An integer of the line number. It is only used for reporting the locations of unexpected ids for debugging.
#' @param matchTable A two-column dataframe, with the first column containing the strings that need to be replaced, and the second column containing the strings after replacement. Example: replace "uniprot:" with "UniProt".
#' @param globalReplace.before A vector of two elements, specifying the global treatment of special characters which are not desired. This action will be taken BEFORE searching by the internal ids for external ids. Default (c("_","-")) is to replace "_" with "-".
#' @param globalReplace.after A vector of two elements, specifying the global treatment of special characters which are not desired. This action will be taken AFTER searching by the internal ids for external ids. Default is a two row matrix, meaning to replace " " with "-", and to replace ":" with "-".
#' @param nreport An integar specifying the limit number of candidate annotations for reporting.
#' @param verbose Logical, TRUE or FALSE. Whether to report warnings.
#' @details This function calls "getXrefAnnotations" from rBioPaxParser to retrieve the external ids and annotations first, then take the first id and unifies the id format according to matchTable. Will report a warning if there is not sufficient number (nreport) of external ids/annotations.
#' @return A three-column dataframe containing the edges from substrates and enzymes to intermediate, and from intermediate to products, using external ids.
#' @export
get_id_annotation<-function(biopax,id,i,matchTable,
                            globalReplace.before=c("_","-"),
                            globalReplace.after=matrix(c(" ",":","-","-"),nrow = 2),
                            nreport=1,verbose=TRUE){
  (tmp.id<-getXrefAnnotations(biopax,id)) #the record uses ";" to split the substrates in an intermediate; uses "_" to split different component members in a substrate
  tmp.store<-id
  countn = 0
  vec.id<-c()
  for(j in 1:nrow(matchTable)){
    if(length(grep(matchTable[j,1],tmp.id$annotation)) > 0){ 
      (id<-tmp.id$annotation[grep(matchTable[j,1],tmp.id$annotation)][1]) #Take the first id if multiple ids are returned
      #convert special characters to "-" to avoid ambiguity. Default is "_" to "-". Can supply customize replacement match table.
      if(is.vector(globalReplace.before)){
        (id<-gsub(globalReplace.before[1],globalReplace.before[2],id))
      }else if(dim(globalReplace.before) >= 1){
        for(k in 1:nrow(globalReplace.before)){
          (id<-gsub(globalReplace.before[k,1],globalReplace.before[k,2],id))
        }
      }else{
        if(verbose){
          print("Invalid data type for symbol replacement before id conversion.")
        }
      }
      
      (id<-gsub(matchTable[j,1],matchTable[j,2],id)) #Remove ":" to avoid potential problems
      
      if(is.vector(globalReplace.after)){
        (id<-gsub(globalReplace.after[1],globalReplace.after[2],id))
      }else if(dim(globalReplace.after) >= 1){
        for(k in 1:nrow(globalReplace.after)){
          (id<-gsub(globalReplace.after[k,1],globalReplace.after[k,2],id))
        }
      }else{
        if(verbose){
          print("Invalid data type for symbol replacement before id conversion.")
        }
      }
      names(id)<-matchTable[j,1]
      (vec.id<-c(vec.id,id))
      (countn = countn + 1)
    }
  }
  
  if(countn == 0){#check countn value. The desired value of countn is 1, since there is only one type of annotation of this id. If 0, then output a warning message to report the unidentified id. If >1, then report a conflicting situation with multiple type of annotations
    #Part of the PhysicalEntity ids are Sets, therefore they have no direct annotations. They needs to be split.
    (tmpvec<-decomplex(tmp.store,hbiopax))
    if(length(tmpvec) > 0){
      tmpvec<-sort(unique(substr(tmpvec,1,regexpr("#",tmpvec)-1)),decreasing = F)
      tmpresult<-c()
      for(j in 1:length(tmpvec)){
        tmpresult<-c(tmpresult,get_id_annotation(biopax,tmpvec[j],i,matchTable)) #referencing to this function itself
      }
      (id<-paste0(tmpresult,collapse = "_"))
    }else{
      if(verbose){
        print(paste0("Id not recognized: ",tmp.store,", line ",i))
      }
      (tmp.index=which(hbiopax$dt$property == "displayName" & hbiopax$dt$id == tmp.store))
      if(length(tmp.index) > 0 ){
        (vec.id[1]<-gsub(" ","-",hbiopax$dt$property_value[tmp.index]))
        vec.id[1]<-gsub("_","-",vec.id[1])
        if(verbose){
          print(paste0("Found displayName, using ",vec.id[1]," as the last option."))
        }
      }else{
        vec.id[1]<-tmp.store
        if(verbose){
          print("Id not converted.")
        }
      }
    }
  }else if(countn > 1){
    #print(paste0(countn," types id annotation detected: ",tmp.store))
  }
  if(length(vec.id) < nreport){
    if(verbose){
      print(paste0("Warning: number of candidate annotation ids is smaller than the required number of ids to report: ",tmp.store))
      print("Printing all of the possible annotated ids")
    }
    nreport<-length(vec.id)
  }
  return(vec.id[1:nreport])
}

#' A wrapper for reading the owl file calling the function "readBiopax" from rBioPaxParser
#' @description This function checks whether there is already a RData file of rBioPax object, if yes, load the existing file, if no, load the given owl file.
#' @param owl A character string specifying the name and location of an owl file.
#' @param out.biopax A character string specifying the name and location of a RData file of rBioPax object.
#' @param flag A character string specifying the state of an variable "input". If input has been initialized, then input should be a string of the name of the owl file (without path). If not, then input will be set to "noFile" before passed to this function.
#' @details If the input owl file name has not been specified in the command line, then this function will cancel the whole process if there's no existing .RData file of the rBioPax object. So it's safer to specify the "--input" option when calling from command line. After loading the owl file, this function will save the object to a file named as "out.biopax" to save time for future loading.
#' @return A rBioPax object loaded from file "owl", and will create a .RData file for this object in local dir.
#' @export
#Wrapper for reading the owl file
read_owl<-function(owl,out.biopax,flag){
  if(file.exists(out.biopax)){
    print(paste0("Using existing biopax file: ",out.biopax))
    load(out.biopax)
  }else if(flag == "noFile"){
    print("The biopax object file does not exist in working dir, without specifying input owl file, exiting...")
    q(save = "no")
  }else{
    hbiopax = readBiopax(owl)
    print(paste0("Saving biopax object to file: ",out.biopax))
    save(hbiopax,file = out.biopax)
  }
  return(hbiopax)
}

#' A wrapper building the dataframe which stores all of the information for all reactions from a rBioPax object.
#' @description This function extracts all of the desired reactions from a rBioPax object into a dataframe, then fill the dataframe with the information of enzymes and modulators.
#' @param out.reactions.full A character string specifying the name and location of an existing .RData file.
#' @param hbiopax A rBioPax object created by function "read_owl".
#' @param verbose Logical for whether or not to report warnings.
#' @details This function will first build a dataframe by extracting the reactions from classes "BiochemicalReaction", "Degradation", "Conversion", "ComplexAssembly", "Transport", "TransportWithBiochemicalReaction", and "TemplateReaction".
#' @details Then it will extract the enzymes from classes "Catalysis" and "Control" for each reaction. Finally, it will extract "Modulation" if there is any. Before it returns the resulting dataframe, it will also save the dataframe to a local file to save time for future loading.
#' @return A dataframe containing all of the reactions from a rBioPax object, with enzymes' and modulators' information.
#' @export
build_reactionsFull<-function(out.reactions.full,hbiopax,verbose=TRUE){
  if(file.exists(out.reactions.full)){
    if(verbose){
      print(paste0("Using existing reactions.full file: ",out.reactions.full))
    }
    load(out.reactions.full)
  }else{
    if(verbose){
      print("Building reactions.full object...")
      print("Extracting reactions...")
    }
    tmp.class<-unique(hbiopax$dt$class)
    reactions.raw<-c()
    if(length(tmp.class[tmp.class == "BiochemicalReaction"]) == 1){
      if(verbose){
        print("Extracting class::BiochemicalReaction...")
      }
      reactions.raw<-rbind(reactions.raw,extract_reactionInfo(hbiopax,"BiochemicalReaction"))
    }else{
      if(verbose){
        print("No class::BiochemicalReaction found.")
      }
    }
    if(length(tmp.class[tmp.class == "Degradation"]) == 1){
      if(verbose){
        print("Extracting class::Degradation...")
      }
      reactions.raw<-rbind(reactions.raw,extract_reactionInfo(hbiopax,"Degradation"))
    }else{
      if(verbose){
        print("No class::Degradation found.")
      }
    }
    if(length(tmp.class[tmp.class == "Conversion"]) == 1){
      if(verbose){
        print("Extracting class::Conversion...")
      }
      reactions.raw<-rbind(reactions.raw,extract_reactionInfo(hbiopax,"Conversion"))
    }else{
      if(verbose){
        print("No class::Conversion found.")
      }
    }
    if(length(tmp.class[tmp.class == "ComplexAssembly"]) == 1){
      if(verbose){
        print("Extracting class::ComplexAssembly...")
      }
      reactions.raw<-rbind(reactions.raw,extract_reactionInfo(hbiopax,"ComplexAssembly"))
    }else{
      if(verbose){
        print("No class::ComplexAssembly found.")
      }
    }
    if(length(tmp.class[tmp.class == "Transport"]) == 1){
      if(verbose){
        print("Extracting class::Transport...")
      }
      reactions.raw<-rbind(reactions.raw,extract_reactionInfo(hbiopax,"Transport"))
    }else{
      if(verbose){
        print("No class::Transport found.")
      }
    }
    if(length(tmp.class[tmp.class == "TransportWithBiochemicalReaction"]) == 1){
      if(verbose){
        print("Extracting class::TransportWithBiochemicalReaction...")
      }
      reactions.raw<-rbind(reactions.raw,extract_reactionInfo(hbiopax,"TransportWithBiochemicalReaction"))
    }else{
      if(verbose){
        print("No class::TransportWithBiochemicalReaction found.")
      }
    }
    if(length(tmp.class[tmp.class == "TemplateReaction"]) == 1){
      if(verbose){
        print("Extracting class::TemplateReaction...")
      }
      reactions.raw<-rbind(reactions.raw,extract_reactionInfo(hbiopax,"TemplateReaction"))
    }else{
      if(verbose){
        print("No class::TemplateReaction found.")
      }
    }
    #####Next section: adding enzymes and modulators
    if(verbose){
      print("Adding enzyme info into the dataframe...")
    }
    if(length(tmp.class[tmp.class == "Catalysis"]) == 1){
      if(verbose){
        print("Adding info for class::Catalysis...")
      }
      reactions.full<-add_enzymeInfo(reactions.raw,hbiopax,"Catalysis",verbose=verbose)
    }else{
      if(verbose){
        print("No class::Catalysis found.")
      }
      reactions.full<-reactions.raw
    }
    if(length(tmp.class[tmp.class == "Control"]) == 1){
      if(verbose){
        print("Adding info for class::Control...")
      }
      reactions.full<-add_enzymeInfo(reactions.full,hbiopax,"Control",verbose=verbose)
    }else{
      if(verbose){
        print("No class::Control found.")
      }
    }
    if(length(tmp.class[tmp.class == "Modulation"]) == 1){
      if(verbose){
        print("Adding info for class::Modulation...")
      }
      reactions.full<-add_modulationInfo(reactions.full,hbiopax,"Modulation",verbose=verbose)
    }else{
      if(verbose){
        print("No class::Modulation found.")
      }
    }
    if(verbose){
      print(paste0("Saving reactions.full object to file: ",out.reactions.full))
    }
    save(reactions.full, file = out.reactions.full)
  }
  return(reactions.full)
}

#' A wrapper building the two-column matching table between complexes and components/elements.
#' @description This function looks for the ids of class "Complex", and calls function "create_complexComponentTable" to build a complex to components matching table.
#' @param hbiopax A rBioPax object created by function "read_owl".
#' @param out.cplx2cpnt A character string specifying the path and name of the output RData file which stores the matching table.
#' @details This function checks the existence of the output RData file, if it exists, then load the R object from the file directly, if not, then go on to build the matching table. 
#' @details Sometimes there's no complexes in the rBioPax object, then this function will return a void dataframe.
#' @return A two-column dataframe containing the matching information between complexes and components/elements.
#' @export
build_cplx2cpnt<-function(hbiopax,out.cplx2cpnt){
  tmp.class<-unique(hbiopax$dt$class)
  if(file.exists(out.cplx2cpnt)){
    print(paste0("Using existing cplx2cpnt file: ",out.cplx2cpnt))
    load(out.cplx2cpnt)
  }else{
    if(length(tmp.class[tmp.class == "Complex"]) == 0){
      print("Warning: no 'Complex' class in the biopax object.")
      print("Created a void matching table for the downstream steps.")
      cplx2cpnt<-c()
    }else{
      print("Building complex to component matching table. This may take several hours...")
      cplx2cpnt<-create_complexComponentTable(hbiopax)
      n.void<-nrow(cplx2cpnt[cplx2cpnt$components == "",])
      if(n.void > 0){
        print(paste0("Warning: ",n.void," complexes do not have any components"))
      }
      cplx2cpnt<-cplx2cpnt[cplx2cpnt$components != "",]
      print(paste0("Saving cplx2cpnt object to file: ",out.cplx2cpnt))
      save(cplx2cpnt, file = out.cplx2cpnt)
    }
  }
  return(cplx2cpnt)
}

#' A wrapper building the GIN in SIFI format with local unreplaced ids.
#' @description This function build a raw dataframe in SIFI format based on the reactions dataframe and the complex matching table.
#' @param out.sif A character string specifying the path and name of the output RData file containing the GIN with local ids.
#' @param reactions.full A dataframe created by function "build_reactionsFull" which contains all the information for all reactions.
#' @param cplx2cpnt A two-column dataframe containing the matching information between complexes and their components/elements.
#' @details This a wrapper building the GIN in SIFI format with local unreplaced ids. It will first check the existence of already-built raw SIFI file. If not exsiting, then it will call the function "convert_toSIF", then save the results into a local file and return the dataframe.
#' @return A three-column dataframe in SIFI format, with starting nodes, ending nodes and edge properties.
#' @export
build_rawSIF<-function(out.sif,reactions.full,cplx2cpnt){
  if(file.exists(out.sif)){
    print(paste0("Using existing sif (local id unreplaced) file: ",out.sif))
    load(out.sif)
  }else{
    print(paste0("Building GIN in sif format, with local unreplaced ids..."))
    tmp.sif<-convert_toSif(reactions.full,cplx2cpnt)
    tmp.sif<-unique(tmp.sif)
    print(paste0("Saving sif dataframe into file: ",out.sif))
    save(tmp.sif,file = out.sif)
  }
  return(tmp.sif)
}

